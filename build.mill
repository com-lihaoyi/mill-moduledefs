//| mill-version: 1.1.0-RC2
//| mill-jvm-version: 11
package build

import mill.scalalib._
import mill.scalalib.publish._
import mill.api.*
import mill.*

object Settings {
  val version = "0.12.4"
  val pomOrg = "com.lihaoyi"
  val githubOrg = "com-lihaoyi"
  val githubRepo = "mill-moduledefs"
  val projectUrl = s"https://github.com/${githubOrg}/${githubRepo}"
}

object Deps {

  // 2.13.18 is latest forward-compatible 2.13 version
  val libScala2Version = "2.13.18"
  // 3.7.4 is forward-compatible to 3.7, which is our lowest supported 3 version
  val libScala3Version = "3.7.4"

  val scalaVersionEnv = sys.env.get("SCALA_VERSION")
    .map(_.trim)
    .filter(_.nonEmpty)
    .tapEach(v => println(s"Adding environmental defined Scala version to version matrix. SCALA_VERSION=${v}"))
    .toSeq

  val scala2Versions = (
    0.to(17).map(v => "2.13." + v) ++
      Seq(libScala2Version) ++
      scalaVersionEnv.filter(_.startsWith("2.13"))
    ).distinct

  val scala3Versions = (
    Seq("3.7.0", "3.7.1", "3.7.2", "3.7.3", "3.7.4", "3.8.0-RC1", "3.8.0-RC2", "3.8.0-RC3") ++
      Seq(libScala3Version) ++
      scalaVersionEnv.filter(_.startsWith("3"))
    ).distinct

  val libScalaVersions = Seq(libScala2Version, libScala3Version)
  val pluginScalaVersions: Map[String, String] =    (
    scala2Versions.map(_ -> libScala2Version) ++
      scala3Versions.map(_ -> libScala3Version)
    ).toMap

  def scalaCompiler(scalaVersion: String) =
    if (scalaVersion.startsWith("3.")) ivy"org.scala-lang::scala3-compiler:${scalaVersion}"
    else ivy"org.scala-lang:scala-compiler:${scalaVersion}"
  val sourcecode = ivy"com.lihaoyi::sourcecode:0.3.0"
}

trait ModuledefsBase extends ScalaModule with PublishModule {
  def publishVersion = Settings.version
  def pomSettings = PomSettings(
    description = artifactName(),
    organization = Settings.pomOrg,
    url = Settings.projectUrl,
    licenses = Seq(License.MIT),
    versionControl = VersionControl.github(Settings.githubOrg, Settings.githubRepo),
    developers = Seq(
      Developer("lihaoyi", "Li Haoyi", "https://github.com/lihaoyi"),
      Developer("lefou", "Tobias Roeser", "https://github.com/lefou")
    )
  )
  def jvmId = Task{ if (scalaVersion().startsWith("3.8.")) "17" else "11" }
  override def javacOptions = Seq("-source", "1.8", "-target", "1.8", "-encoding", "UTF-8")
  override def scalacOptions = Task {
    super.scalacOptions() ++ (
      if (scalaVersion().startsWith("3.")) Seq("-Yexplicit-nulls", "-no-indent")
      else Seq.empty
    )
  }
}

object moduledefs extends Cross[ModuleDefsCross](Deps.libScalaVersions)
trait ModuleDefsCross extends CrossScalaModule  with ModuledefsBase {
  outer =>
  override def artifactName = "mill-" + super.artifactName()

  override def mvnDeps = {
    val sv = crossScalaVersion
    Seq(Deps.sourcecode) ++
      (if (sv.startsWith("2.")) Seq(Deps.scalaCompiler(sv)) else Seq.empty)
  }
}

object plugin extends Cross[PluginCross](Deps.pluginScalaVersions.keys.toSeq)
trait PluginCross extends CrossScalaModule with ModuledefsBase {
  override def moduleDir = moduledefs.moduleDir / "plugin"
  override def artifactName = "scalac-mill-moduledefs-plugin"
  override def moduleDeps = Seq(moduledefs(Deps.pluginScalaVersions(crossScalaVersion)))
  override def crossFullScalaVersion = true
  override def mvnDeps = Seq(
    Deps.scalaCompiler(crossScalaVersion),
    Deps.sourcecode
  )

  def versionedResources = Task.Sources(
    scalaVersionDirectoryNames.map(dir => moduleDir / s"resources-$dir")*
  )
  override def resources = Task {
    super.resources() ++ versionedResources()
  }
}
