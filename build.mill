//| mill-version: 1.1.0-RC2
//| mill-jvm-version: 11
import mill.scalalib._
import mill.scalalib.publish._
import mill.api.*
import mill.*
object Settings {
  val version = "0.12.5"
  val pomOrg = "com.lihaoyi"
  val githubOrg = "com-lihaoyi"
  val githubRepo = "mill-moduledefs"
  val projectUrl = s"https://github.com/${githubOrg}/${githubRepo}"
}

object Deps {
  val scala2Versions = 0.to(15).map(v => "2.13." + v)
  val scala3Versions = Seq("3.7.0", "3.7.1", "3.7.2", "3.7.3", "3.7.4", "3.8.0-RC1", "3.8.0-RC2", "3.8.0-RC3", "3.8.0-RC4")
  val scalaAllVersions = Map(
    scala2Versions.last -> scala2Versions,
    "3.7.4" -> scala3Versions,
  )
  def scalaCompiler(scalaVersion: String) =
    if (scalaVersion.startsWith("3.")) ivy"org.scala-lang::scala3-compiler:${scalaVersion}"
    else ivy"org.scala-lang:scala-compiler:${scalaVersion}"
  val sourcecode = ivy"com.lihaoyi::sourcecode:0.3.0"
}

trait ModuledefsBase extends ScalaModule with PublishModule {
  def publishVersion = Settings.version
  def pomSettings = PomSettings(
    description = artifactName(),
    organization = Settings.pomOrg,
    url = Settings.projectUrl,
    licenses = Seq(License.MIT),
    versionControl = VersionControl.github(Settings.githubOrg, Settings.githubRepo),
    developers = Seq(
      Developer("lihaoyi", "Li Haoyi", "https://github.com/lihaoyi"),
      Developer("lefou", "Tobias Roeser", "https://github.com/lefou")
    )
  )
  def jvmId = Task{ if (scalaVersion().startsWith("3.8.")) "17" else "11" }
  override def javacOptions = Seq("-source", "1.8", "-target", "1.8", "-encoding", "UTF-8")
  override def scalacOptions = Task {
    super.scalacOptions() ++ (
      if (scalaVersion().startsWith("3.")) Seq("-Yexplicit-nulls", "-no-indent")
      else Seq.empty
    )
  }
}

object moduledefs extends Cross[ModuleDefsCross](Deps.scalaAllVersions.keys.toSeq)
trait ModuleDefsCross extends CrossScalaModule  with ModuledefsBase { outer =>
  override def artifactName = "mill-" + super.artifactName()
  override def mvnDeps = {
    val sv = crossScalaVersion
    Seq(Deps.sourcecode) ++
      (if (sv.startsWith("2.")) Seq(Deps.scalaCompiler(sv)) else Seq.empty)
  }

  object plugin extends Cross[PluginCross](Deps.scalaAllVersions(crossScalaVersion))
  trait PluginCross extends CrossScalaModule
      with ModuledefsBase {
    override def artifactName = "scalac-mill-moduledefs-plugin"
                                          // ^^ TODO: cant use `"scalac-mill-" + super.artifactName()` here
                                          //    because it includes the crossScalaVersion of `moduledefs`
                                          //    could be addressed with Cross2 from mill 0.11.x
    override def moduleDeps = Seq(moduledefs(outer.crossScalaVersion))
    override def crossFullScalaVersion = true
    override def mvnDeps = Seq(
      Deps.scalaCompiler(crossScalaVersion),
      Deps.sourcecode
    )

    def versionedResources = Task.Sources(
      scalaVersionDirectoryNames.map(dir => moduleDir / s"resources-$dir")*
    )
    override def resources = Task {
      super.resources() ++ versionedResources()
    }
  }
}

def publishToSonatype(
    sonatypeCreds: String,
    gpgArgs: String = PublishModule.defaultGpgArgs.mkString(","),
    dryRun: Boolean = false,
    artifactsFile: Option[String] = None,
    eval: Evaluator
): Command[Unit] = {

  val pubTasks: Seq[String] = artifactsFile.map(f => os.Path(f, os.pwd)).filter(os.exists) match {
    case None => Seq("__.publishArtifacts")
    case Some(f) =>
      val tasks = os.read.lines(f)
        .map(_.trim())
        .filter(l => l.nonEmpty && !l.startsWith("#"))
      if (tasks.isEmpty) sys.error(s"No artifacts tasks selected. File ${f} cannot be empty.")
      tasks
  }

  val Result.Success(tasks) = eval.resolveTasks(
    pubTasks,
    SelectMode.Separated
  )

  Task.Command {
    val pubArtifacts: Seq[(Seq[(os.Path, String)], Artifact)] = Task.sequence(tasks)().map {
      case PublishModule.PublishData(a, s) => (s.map { case (p, f) => (p.path, f) }, a)
    }

    Task.log.debug(s"Publishing artifacts: ${pubArtifacts.map(_._2).mkString("\n  ", "\n  ", "")}")

    if (dryRun) {
      Task.log.info(
        s"Skipping publish for artifacts: ${pubArtifacts.map(_._2).mkString("\n  ", "\n  ", "")}"
      )
    } else {
      new SonatypePublisher(
        uri = "https://oss.sonatype.org/service/local",
        snapshotUri = "https://oss.sonatype.org/content/repositories/snapshots",
        sonatypeCreds,
        signed = true,
        gpgArgs.split(',').toIndexedSeq,
        readTimeout = 6000000,
        connectTimeout = 600000,
        Task.log,
        BuildCtx.workspaceRoot,
        Task.env,
        awaitTimeout = 600000,
        stagingRelease = true
      ).publishAll(
        release = true,
        pubArtifacts: _*
      )
    }
  }

}
